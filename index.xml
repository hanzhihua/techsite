<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>一个码农 工作点滴</title>
    <link>https://hanzhihua.cn/</link>
    <description>Recent content on 一个码农 工作点滴</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>All rights reserved - 2019 沪ICP备19026538号 </copyright>
    <lastBuildDate>Tue, 20 Aug 2019 20:00:11 +0800</lastBuildDate>
    
        <atom:link href="https://hanzhihua.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>负载均衡的问题</title>
      <link>https://hanzhihua.cn/post/lb_1/</link>
      <pubDate>Tue, 20 Aug 2019 20:00:11 +0800</pubDate>
      
      <guid>https://hanzhihua.cn/post/lb_1/</guid>
      
        <description>

&lt;p&gt;最近线上出现一个故障，DAG系统调用hiveserver集群时，hiveserver集群有一个节点出现了crash
，造成了DAG系统出现大量错误&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DAG系统维护hiveserver ip列表，使用smartclient方案来完成failover&lt;/li&gt;
&lt;li&gt;功能实现中有bug，造成了系统failover失败&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有同学提出意见，说无状态系统的高可用应该采用四层路由方式来保证&lt;/p&gt;

&lt;p&gt;&lt;em&gt;四层路由一般指haproxy、nginx tcp stream、lvs+keepalived&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;说说四层路由方式的优缺点&#34;&gt;说说四层路由方式的优缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;优点&lt;br /&gt;
节点探活，自动上下线&lt;br /&gt;
支持多种负载均衡策略&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;缺点&lt;br /&gt;
节点探活只是在系统层面，无法做到应用层面
负载均衡策略也无法根据应用性能做出正确的判断&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;应用性能4个重要指标：延迟、错误率、吞吐、饱和度。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Jar包冲突问题</title>
      <link>https://hanzhihua.cn/post/jarconflict/</link>
      <pubDate>Fri, 16 Aug 2019 11:33:48 +0800</pubDate>
      
      <guid>https://hanzhihua.cn/post/jarconflict/</guid>
      
        <description>

&lt;p&gt;今天发现了上线版本出现jar冲突问题&lt;/p&gt;

&lt;h2 id=&#34;jar包冲突&#34;&gt;jar包冲突&lt;/h2&gt;

&lt;p&gt;一般是下面两种情况&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目中依赖同一个jar的不同版本&lt;/li&gt;
&lt;li&gt;同一个class存在在不同的jar包中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述情况都会在运行中发生异常，造成麻烦&lt;/p&gt;

&lt;p&gt;可以加上&lt;a href=&#34;https://maven.apache.org/enforcer/maven-enforcer-plugin/&#34;&gt;enforcer&lt;/a&gt;插件，在项目打包时做检查&lt;/p&gt;

&lt;p&gt;加上这个&lt;a href=&#34;https://www.mojohaus.org/extra-enforcer-rules/banDuplicateClasses.html&#34;&gt;banDuplicateClasses规则&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-enforcer-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt; &amp;lt;!-- find the latest version at http://maven.apache.org/plugins/maven-enforcer-plugin/ --&amp;gt;
        &amp;lt;executions&amp;gt;
          &amp;lt;execution&amp;gt;
            &amp;lt;id&amp;gt;default-cli&amp;lt;/id&amp;gt;
            &amp;lt;goals&amp;gt;
              &amp;lt;goal&amp;gt;enforce&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
            &amp;lt;configuration&amp;gt;
              &amp;lt;rules&amp;gt;
                &amp;lt;banDuplicateClasses&amp;gt;
                  &amp;lt;scopes&amp;gt;
                      &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
                      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
                  &amp;lt;/scopes&amp;gt;
                  &amp;lt;findAllDuplicates&amp;gt;true&amp;lt;/findAllDuplicates&amp;gt;
                  &amp;lt;ignoreWhenIdentical&amp;gt;true&amp;lt;/ignoreWhenIdentical&amp;gt;
                &amp;lt;/banDuplicateClasses&amp;gt;
              &amp;lt;/rules&amp;gt;
              &amp;lt;fail&amp;gt;true&amp;lt;/fail&amp;gt;
            &amp;lt;/configuration&amp;gt;
          &amp;lt;/execution&amp;gt;
        &amp;lt;/executions&amp;gt;
        &amp;lt;dependencies&amp;gt;
          &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;extra-enforcer-rules&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
          &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
      &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
  &amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>hive语句太长问题</title>
      <link>https://hanzhihua.cn/post/dag_1/</link>
      <pubDate>Thu, 15 Aug 2019 20:30:17 +0800</pubDate>
      
      <guid>https://hanzhihua.cn/post/dag_1/</guid>
      
        <description>&lt;p&gt;今天有一个同学写了一个超长的hive脚本， &amp;gt; 1000行，在执行ADHOC的时候出现错误&lt;/p&gt;

&lt;p&gt;分析原因，因为DAG系统的作业信息是存在mysql，作业的命令是text格式的，最大只有65535，超过mysql限制长度就
报错误了&lt;/p&gt;

&lt;p&gt;考虑到作业的命令是多条hql语句(以逗号分隔)，都比较长，后续将采用小文件方式来存放&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>使用消息中间件来均分任务</title>
      <link>https://hanzhihua.cn/post/mqtask/</link>
      <pubDate>Sun, 11 Aug 2019 15:04:12 +0800</pubDate>
      
      <guid>https://hanzhihua.cn/post/mqtask/</guid>
      
        <description>

&lt;h2 id=&#34;业务场景&#34;&gt;业务场景&lt;/h2&gt;

&lt;p&gt;需要把一下大任务，均分到不同节点中去计算，利用集群规模来快速完成任务&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;利用消息中间件的消息分配（任务分配）、容错、消费者（计算节点）的自动扩缩容，就可以非常简单的完成该功能。&lt;/p&gt;

&lt;p&gt;主要是利用rocketmq机制。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;建立topic，&lt;strong&gt;保证queue数量大于工作节点数量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由任务发起节点，把大任务拆分一个个小任务，发送到消息中间件&lt;/li&gt;
&lt;li&gt;各个任务处理节点按照分配对来处理小任务&lt;/li&gt;
&lt;li&gt;上报任务处理状态&lt;/li&gt;
&lt;/ul&gt;



&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;https://hanzhihua.cn/Snip20190812_219.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;https://hanzhihua.cn/Snip20190812_219.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;

</description>
      
    </item>
    
    <item>
      <title>服务进程管理脚本</title>
      <link>https://hanzhihua.cn/post/control_shell/</link>
      <pubDate>Sat, 10 Aug 2019 18:09:05 +0800</pubDate>
      
      <guid>https://hanzhihua.cn/post/control_shell/</guid>
      
        <description>&lt;p&gt;在生成环境中，一般是使用&lt;a href=&#34;http://supervisord.org/&#34;&gt;supervisor&lt;/a&gt;来管理服务进程（运行在k8s平台上的服务，那就不需要了）&lt;/p&gt;

&lt;p&gt;但有的时候，我们可能采用简单的方式处理，对服务进程进行管理，就是简单的写一个control.sh&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;模板：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

WORK_DIR=$(cd $(dirname $0)/; pwd)
cd $WORK_DIR

SERVICE_NAME=服务名
PID_FILE=$SERVICE_NAME.pid
LOG_FILE=$SERVICE_NAME.out
SERVICE_CMD=服务启动脚本

function check_pid() {
if [ -f $PID_FILE ];then
    pid=`cat $PID_FILE`
    if [ -n $pid ]; then
        running=`ps -p $pid|grep -v &amp;quot;PID TTY&amp;quot; |wc -l`
        return $running
    fi
fi
return 0
}

function start() {
check_pid
running=$?
if [ $running -gt 0 ];then
    echo -n &amp;quot;$SERVICE_NAME now is running already, pid=&amp;quot;
    cat $PID_FILE
    return 1
fi

nohup $SERVICE_CMD   &amp;amp;&amp;gt; $LOG_FILE &amp;amp;
echo $! &amp;gt; $PID_FILE
echo &amp;quot;$SERVICE_NAME started..., pid=$!&amp;quot;
}

function stop() {
pid=`cat $PID_FILE`
kill $pid
echo &amp;quot;$SERVICE_NAME stoped...&amp;quot;
}

function restart() {
stop
sleep 1
start
}

function status() {
check_pid
running=$?
if [ $running -gt 0 ];then
    echo -n &amp;quot;$SERVICE_NAME now is running, pid=&amp;quot;
    cat $PID_FILE
else
    echo &amp;quot;$SERVICE_NAME is stoped&amp;quot;
fi
}

function tailf() {
tail -f $logfile
}

function help() {
echo &amp;quot;$0 start|stop|restart|status|tail&amp;quot;
}

if [ &amp;quot;$1&amp;quot; == &amp;quot;&amp;quot; ]; then
help
elif [ &amp;quot;$1&amp;quot; == &amp;quot;stop&amp;quot; ];then
stop
elif [ &amp;quot;$1&amp;quot; == &amp;quot;start&amp;quot; ];then
start
elif [ &amp;quot;$1&amp;quot; == &amp;quot;restart&amp;quot; ];then
restart
elif [ &amp;quot;$1&amp;quot; == &amp;quot;status&amp;quot; ];then
status
elif [ &amp;quot;$1&amp;quot; == &amp;quot;tail&amp;quot; ];then
tailf
else
help
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>使用Goreplay来做压测</title>
      <link>https://hanzhihua.cn/post/goreplay1/</link>
      <pubDate>Fri, 09 Aug 2019 16:07:22 +0800</pubDate>
      
      <guid>https://hanzhihua.cn/post/goreplay1/</guid>
      
        <description>

&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;

&lt;p&gt;项目要做一个性能测试，希望能最大限度的模拟用户真实请求。&lt;/p&gt;

&lt;p&gt;项目特点弱安全性，无用户标识&lt;/p&gt;

&lt;h1 id=&#34;解决方案&#34;&gt;解决方案&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href=&#34;https://github.com/buger/goreplay&#34;&gt;goreplay&lt;/a&gt;来录制用户请求，来做压测样本&lt;/li&gt;
&lt;li&gt;登录线上服务器，录制请求&lt;br /&gt;
./gor &amp;ndash;input-raw :线上端口 &amp;ndash;output-file=input.gor &amp;ndash;output-file-append&lt;/li&gt;
&lt;li&gt;在压测机，放大流量压测&lt;br /&gt;
./gor &amp;ndash;input-file &amp;ldquo;input.gor|450000% &amp;ndash;output-http http://测试服务器IP:测试服务器port &amp;ndash;input-file-loop &amp;ndash;exit-after 60m&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>WEB端高可用默认玩法</title>
      <link>https://hanzhihua.cn/post/ha/</link>
      <pubDate>Thu, 08 Aug 2019 18:50:43 +0800</pubDate>
      
      <guid>https://hanzhihua.cn/post/ha/</guid>
      
        <description>

&lt;h1 id=&#34;web服务高可用设计&#34;&gt;WEB服务高可用设计&lt;/h1&gt;

&lt;p&gt;主要是从以下几个方面去考虑，设计不考虑dns,动静态CDN&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;架构是slb+keepalived+web服务（针对运维高可用，需要做少量工作）&lt;/li&gt;
&lt;li&gt;slb开源可选方案lvs、haproxy、nginx&lt;/li&gt;
&lt;li&gt;slb是可以分层的,主要看项目规模&lt;/li&gt;
&lt;li&gt;高可用要需要跟CICD配合，web端需要做点工作&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;标准部署架构&#34;&gt;标准部署架构&lt;/h1&gt;



&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;https://hanzhihua.cn/Snip20190814_238.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;https://hanzhihua.cn/Snip20190814_238.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;


&lt;h1 id=&#34;标准玩法&#34;&gt;标准玩法&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Nginx 配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;upstream api {
server *:8080 weight=5;
server *:8080 weight=5;
server *:8080 weight=5;
server *:8080 weight=5;
check interval=3000 rise=2 fall=3 timeout=1000 type=http;
check_http_send &amp;quot;HEAD /health/status HTTP/1.0\r\n\r\n&amp;quot;;
check_http_expect_alive http_2xx http_3xx;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;web端改造(java语言)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
@RequestMapping(&amp;quot;/health&amp;quot;)
public class HealthController {

	private static boolean healthFlag = false;

	//白名单
	private static Set&amp;lt;String&amp;gt; ipSet = new HashSet&amp;lt;String&amp;gt;();

	static {
		ipSet.add(&amp;quot;******&amp;quot;);
	}

	//项目启动时触发 （由运维发布时触发）
	@RequestMapping(&amp;quot;/active&amp;quot;)
	public void active(HttpServletRequest request, HttpServletResponse response) {
		String ip = HttpUtils.getRemoteIP(request);
		if (ipSet.contains(ip)) {
			healthFlag = true;
		} else {
			response.setStatus(HttpServletResponse.SC_FORBIDDEN);
		}
	}

	//项目关闭时触发 由运维发布时触发）
	@RequestMapping(&amp;quot;/offline&amp;quot;)
	public void offline(HttpServletRequest request, HttpServletResponse response) {
		String ip = HttpUtils.getRemoteIP(request);
		if (ipSet.contains(ip)) {
			healthFlag = false;
		} else {
			response.setStatus(HttpServletResponse.SC_FORBIDDEN);
		}
	}
	
	//nginx来探测的URL，来判断web端是否上下线
	@RequestMapping(&amp;quot;/status&amp;quot;)
	public void status(HttpServletRequest request, HttpServletResponse response) {
		response.setStatus(healthFlag ? HttpServletResponse.SC_OK : HttpServletResponse.SC_FORBIDDEN);
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>血缘分析</title>
      <link>https://hanzhihua.cn/post/table_relate/</link>
      <pubDate>Thu, 08 Aug 2019 12:43:34 +0800</pubDate>
      
      <guid>https://hanzhihua.cn/post/table_relate/</guid>
      
        <description>

&lt;p&gt;数据血缘就是分析数据之间的关系，是数据平台中元信息管理重要组成部分&lt;/p&gt;

&lt;p&gt;元信息是指数据平台中存储数据的元信息，就是各种类型表的元信息管理，一般包括 hive、hbase、mysql、ES、mongo、kafka(&lt;em&gt;topic及内部数据格式&lt;/em&gt;)&lt;/p&gt;

&lt;h1 id=&#34;概念&#34;&gt;概念：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;表： hive表，BI报表。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;作业：对应一个sql文件，或者数据收集，数据转移任务，一个可以独立执行的程序；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;项目： DAG系统中概念，包含多个作业；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;数据的血缘关系&#34;&gt;数据的血缘关系：&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;作业跟作业之间的血缘追溯&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;表跟作业之间的血缘追溯&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;表跟表之间的血缘追溯&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字段级别的血缘追溯&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;功能图&#34;&gt;功能图&lt;/h1&gt;



&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;https://hanzhihua.cn/Snip20190808_213.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;https://hanzhihua.cn/Snip20190808_213.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;


&lt;h1 id=&#34;怎么做&#34;&gt;怎么做&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;在DAG任务平台对sql语句、非sql（spark,MR）进行血缘挖掘&lt;/li&gt;
&lt;li&gt;DAG平台中，项目依赖关系&lt;/li&gt;
&lt;li&gt;对BI报表使用的数据源与DAG任务生成的数据源进行管理&lt;/li&gt;
&lt;li&gt;对存储引擎进行元信息同步&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;如何做&#34;&gt;如何做&lt;/h1&gt;

&lt;p&gt;TODO&amp;hellip;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>去zk网络分区容错方案</title>
      <link>https://hanzhihua.cn/post/zkchange/</link>
      <pubDate>Mon, 05 Aug 2019 20:32:50 +0800</pubDate>
      
      <guid>https://hanzhihua.cn/post/zkchange/</guid>
      
        <description>

&lt;p&gt;最近在重构一个DAG系统，遇到一个组件节点通信、及节点发现的问题。&lt;/p&gt;

&lt;h1 id=&#34;原方案&#34;&gt;原方案&lt;/h1&gt;

&lt;p&gt;基本上就是传统的解决方案，服务发现、调用依赖zookeeper&lt;br /&gt;
部署图&lt;br /&gt;


&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;https://hanzhihua.cn/Snip20190805_207.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;https://hanzhihua.cn/Snip20190805_207.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;
&lt;br /&gt;
这个方案，有一个致命问题就是当执行节点与zk出现网络不稳定时，会造成控制节点做出错误的决定&lt;br /&gt;
这个时候也许控制节点与执行节点的通信是非常正常，这就是典型的网络分区问题&lt;br /&gt;
考虑到 控制节点与执行节点之间的通信还是主要，而与zk的通信就不是那么的重要，所以减少对zk的依赖，
只处理zk的节点上线通知，对于下线通知就不处理了，改成依赖节点间的心跳&lt;/p&gt;

&lt;h1 id=&#34;新方案&#34;&gt;新方案&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;只侦听zk的节点新增通知，忽略节点下线的通知&lt;/li&gt;
&lt;li&gt;在执行节点与通信节点新增心跳&lt;/li&gt;
&lt;li&gt;节点下线，由心跳超时来确定&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;https://hanzhihua.cn/Snip20190805_210.png&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;https://hanzhihua.cn/Snip20190805_210.png&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;


&lt;h1 id=&#34;附加知识点&#34;&gt;附加知识点&lt;/h1&gt;

&lt;p&gt;在开发节点心跳功能时，需要对网络timeout类型完全理解。&lt;/p&gt;

&lt;p&gt;案例分析，出现下面异常：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;2019-08-02 18:44:59.476 controlnode [nioEventLoopGroup-2-1] c.b.a.c.j.i.net.NettyChannelClient.exceptionCaught ERROR - error while pipeline: {}
java.io.IOException: Operation timed out
	at sun.nio.ch.FileDispatcherImpl.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:39)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:311)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:881)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:241)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:119)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多同学会认为是应用层中设置的connectiontimeout,或者sotimeout,其实&lt;strong&gt;可能&lt;/strong&gt;都不是&lt;br /&gt;
而是TCP层 &lt;strong&gt;报文失败重传 timeout&lt;/strong&gt;&lt;br /&gt;
可以使用tcpdump来查看就明白了&lt;br /&gt;
TCP层会对报文重传，分超时重传、快速重传，如果当重传报文多次没有收到ack，kernel会reset连接,对应应用层就收到了上述的异常&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>对话机器人设计</title>
      <link>https://hanzhihua.cn/post/chatbot/</link>
      <pubDate>Sat, 03 Aug 2019 22:43:59 +0800</pubDate>
      
      <guid>https://hanzhihua.cn/post/chatbot/</guid>
      
        <description>

&lt;p&gt;最近在研究机器人对话场景，里面涉及的内容比较多，主要以工程的角度去简单实现。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用word2vec(利用&lt;a href=&#34;https://github.com/hankcs/HanLP&#34;&gt;hanlp&lt;/a&gt;)，以概率论的方式简单实现&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持词槽判断&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持流程意图判断&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;组件图&#34;&gt;组件图&lt;/h1&gt;



&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;https://hanzhihua.cn/chatbot.jpg&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;https://hanzhihua.cn/chatbot.jpg&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
  &lt;/figure&gt;
&lt;/div&gt;

</description>
      
    </item>
    
    <item>
      <title>关于</title>
      <link>https://hanzhihua.cn/about/</link>
      <pubDate>Thu, 25 Jul 2019 00:38:52 +0800</pubDate>
      
      <guid>https://hanzhihua.cn/about/</guid>
      
        <description>

&lt;p&gt;我叫韩志华，很高兴你能找到这里，这是我的个人站点。这个站点的域名是 hanzhihua.cn ，我名字的拼音 hanzhihua ，再加上 .cn 后缀。&lt;/p&gt;

&lt;h2 id=&#34;关于我&#34;&gt;关于我&lt;/h2&gt;

&lt;p&gt;近20年软件开发经验，一直就职于各个大型互联网公司，带过中间件团队，基础服务团队，负责过大数据平台。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目前在一家互联网公司，负责大数据平台&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本人爱好比较少，主要就是两个爱好，写代码和与朋友聊天（主要是闲扯）。另外也喜欢玩狼人杀，但因为组织起来太费劲，基本上也不怎么玩了&lt;/p&gt;

&lt;h2 id=&#34;关于本站的建站目的&#34;&gt;建站目的&lt;/h2&gt;

&lt;p&gt;本站的内容都是原创，记录我工作中技术遇到各种点滴及趣味，主要分 分布式、大数据、人工智能、基础设施、编程语言、其他 六个模块
希望大家能喜欢，大家有什么技术问题也可以咨询我。&lt;br /&gt;
QQ: 8187347&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
